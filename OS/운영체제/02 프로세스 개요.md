# 02 프로세스 개요

# 목차
- [프로세스](#1-프로세스)
- [쓰레드](#2-쓰레드)
- [스케줄링](#3-스케줄링)

## 1 프로세스

- **프로세스**
    - **프로세스(process) : 실행중인 프로그램**
    - 프로세스 : 동작을 하는 능동적 개체
    
![Untitled](https://user-images.githubusercontent.com/80089860/160265304-f75536e9-8f7c-4b06-9a60-cbd910e41898.png)

- **운영체제로부터 자원을 할당 받아 동작**
    - 자원 : CPU, 메모리, 입출력장치, 파일 등
    - 동작 : CPU가 프로세스의 명령을 실행
    
- **사용자 및 시스템 프로세스 존재**

### 프로세스와 운영체제

- 프로세스 관리자의 역할
    - 프로세스를 생성 및 삭제
    - 프로세스 실행(CPU 할당)을 위한 스케줄 결정
    - 프로세스의 상태를 관리하며 상태 전이를 처리

### 프로세스와 운영체제

- **5-상태모델**

![Untitled 1](https://user-images.githubusercontent.com/80089860/160265311-8887b82c-7864-4fca-94af-a66def877c5b.png)

![Untitled 2](https://user-images.githubusercontent.com/80089860/160265313-4ab6f850-320b-4e56-a7c6-98c548bfa06d.png)

### 프로세스 제어블록(PCB, Process Control Block)

- 프로세스의 관리를 위한 목적
- 프로세스의 정보를 보관
- 각 프로세스마다 존재
- 프로세스가 진행함에 따라 내용변경

![Untitled 3](https://user-images.githubusercontent.com/80089860/160265314-1a42685c-463d-412d-9fd9-60940d6048cc.png)

### 프로세스 생성과 종료

- **프로세스 생성작업**
    - 프로세서의 이름(번호, PID) 결정
    - 준비 큐에 삽입
    - 초기 우선순위 부여
    - 프로세스 제어 블록(PCB) 생성 등
- **프로세스 생성방법 : 시스템 호출**
- **프로세스 생성 시스템 호출**
    - 하나의 프로세스가 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성 예시. fork()
    - 호출하는 프로세스 : 부모 프로세스
    - 생성되는 프로세스 : 자식 프로세스
- **시스템 프로세스와 사용자 프로세스 모두 부모 프로세스 가능**
- **생성되는 프로세스의 자원**
    - 운영체제로부터 직접 얻는 경우
    - 부모 프로세스 자원의 일부를 얻는 경우
- **자식 프로세스의 자원은 부모 프로세스의 자원으로 제한**
    - 과도한 자식 프로세스 생성에 따른 시스템 과부하 방지

- **프로세스 종료**
    - 프로세스의 마지막 명령이 실행을 마치는 경우
    - 프로세스 종료 시스템 호출(예:exit())을 통하는 경우
    - 프로세스 종료 후 부모 프로세스에게 실행결과를 되돌려 줌
- **프로세스 종료 시스템 호출**

![Untitled 4](https://user-images.githubusercontent.com/80089860/160265315-237bd403-6a78-4f7e-bafa-790b5a212d20.png)

## 2 쓰레드

- **전통적인 프로세스**
    - **처리의 기본 단위**
    - 자원 소유의 단위(하나의 주소공간) 및 디스패칭의 단위(하나의 제어흐름)
    - **단일 프로세스 내에서 동시처리 불가능 → 쓰레드 등장**

- **쓰레드(Thread)**
    - 프로세스 내에서의 다중처리를 위해 제안된 개념
    - 하나의 프로세스 내에는 하나 이상의 쓰레드가 존재
    - 하나의 쓰레드 내에서는 하나의 실행점만 존재(디스패칭의 단위)
    - 실행에 필요한 최소한의 정보만을 가지며, 자신이 속해 있는 프로세스의 실행환경을 공유
    
![Untitled 5](https://user-images.githubusercontent.com/80089860/160265320-ab40a862-feea-448f-913c-a4db0d19b03a.png)

- **다중 쓰레드의 장점**
    - 멀티 CPU 혹은 멀티코어 시스템에서는 병렬처리 가능
    - 처리 속도 별로 쓰레드가 나눠진 경우 효율적인 처리 가능
    
![Untitled 6](https://user-images.githubusercontent.com/80089860/160265324-588c1497-286f-4940-962c-7fba17452c57.png)

## 3 스케줄링

![Untitled 7](https://user-images.githubusercontent.com/80089860/160265327-95c8730d-e205-4c36-a562-1d36d3d4b40d.png)

### 상위단계 스케줄링

- 시스템에 들어오는 작업들을 선택하여 프로세스를 생성한 후 프로세스 준비큐에 전달
- 선택 기준 : 시스템의 자원을 효율적으로 이용할 수 있도록 하는 것
- 입출력(I/O) 중심 작업과 연산 중심 작업을 균형있게 선택

![Untitled 8](https://user-images.githubusercontent.com/80089860/160265331-57747c7d-7284-4113-b185-cac099b4d601.png)

### 하위단계 스케줄링

- 사용 가능한 CPU를 준비상태의 어느 프로세스에게 배당할지를 결정
- CPU를 배당받은 프로세스는 결국 실행상태가 되어 프로세스가 처리됨
- 수행 주체 : 디스패처(dispatcher)

![Untitled 9](https://user-images.githubusercontent.com/80089860/160265333-00d72c94-0feb-4d86-a927-2e41db93930a.png)

### 중간단계 스케줄링

- 프로세스를 일시적으로 메모리에서 제거하여 중지시키거나 다시 활성화시킴
- 시스템에 대한 단기적인 부하를 조절

![Untitled 10](https://user-images.githubusercontent.com/80089860/160265340-08993813-4bb0-45de-8f73-7d8d8bc2cd04.png)

## 스케줄링 정책

### 1. 선점(Preemptive) 스케줄링 정책

- 진행중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당하는 스케줄링 전략
- 높은 우선순위의 프로세스를 긴급하게 처리하는 경우에 유용
- 대화식 시분할 시스템에서 빠른 응답시간을 유지하는데 유용
- 문맥 교환에 따른 오버헤드 발생

.*문맥 : CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태

### 2. 비선점(NonPreemptive) 스케줄링 정책

- 프로세스가 CPU를 할당받아 실행이 시작되면 작업 자체가 I/O 인터럽트를 걸거나 작업을 종료 할 때까지 실행상태에 있게됨
- 모든 프로세스가 공정하게 순서에 따라 실행됨 → 응답시간 예측가능
- 짧은 프로세스가 긴 프로세스를 기다리게 될 수 있음
