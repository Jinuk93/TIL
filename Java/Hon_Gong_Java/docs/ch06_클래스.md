# 6강. 클래스

- **클래스 : 객체를 만들기 위한 설계도**
- **객체 : 클래스로부터 생성되며 ‘new 클래스()’로 생성합니다.**
- **new 연산자 : 객체 생성 연산자이며, 생성자를 호출하고 객체 생성 번지를 리턴합니다.**
- **클래스 변수 : 클래스로 선언한 변수를 말하며 해당 클래스의 객체 번지가 저장됩니다.**
- **인스턴스 : 객체는 클래스의 인스턴스입니다.**
- **클래스 멤버 : 클래스에 선언되는 멤버는 필드, 생성자, 메소드가 있습니다.**

예시

**Student s1 = new Student();**

**s1 이라는 객체명은  Student의 번지를 갖게된다 ( 객체 생성 → 참조 )**

**new는객체 생성**

---

### 클래스의 개념 ( 필드 + 생성자 + 메소드 )

## 객체 지향 프로그래밍

![Untitled](https://user-images.githubusercontent.com/80089860/162865080-34847095-afde-46a7-a608-b04e3876ffe0.png)

## *객체(Object) : 필드(field) + 메소드(method) 로 구성*

***객체(필드, 메소드) + 생성자 = 클래스***

- **물리적 : 자동차( 모델명, 색상)**
- **추상적 : 회사( 설립연도, 대표이사, 회사명)**

**등의 속성+동작을 가진 것**

📌

### 필드(field) : 속성 (**이름, 나이, 색깔, 속도)**

### 메소드(method) : 동작(웃**다, 먹다, 달린다, 멈춘다)**

### 객체 모델링(object modeling)

**: 현실 세계의 객체를 소프트웨어의 객체로 설계하는 것**

### 객체의 상호작용

### 📌메소드

- **“메소드”를 통해 객체들이 상호작용**
- **메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것**

<aside>
📖 📌쉽게 말해, 메소드는 “동작”,”기능”과 같은 개념

</aside>

⭐⭐⭐⭐⭐

**📌예시**

**Calculator.add() 라는 “메소드”가 있다. 이 메소드는 숫자를 더하는 “기능”이 있다 ⇒ 메소드 개념**

**그래서 “나”라는 객체가 “Caluator”의 전자계산기라는 객체에 ⇒ 객체의 상호작용**

 **Calculator.add() 라는 “메소드를 호출”해서 숫자들을 더하려고 한다 ⇒ 메소드 호출**

**이 때, 더하려고 하는 숫자들을 “매개값”이라고 한다 ⇒ 매개값 의미**

**그리고 숫자들을 더한 int result를 “리턴값” 이라고 한다 ⇒ 리턴값의 의미**

<aside>
📖 int result = Calculator.add(10, 20);

</aside>

- **int result ⇒ 리턴값 ( 리턴값을 int 타입의 result 변수에 값저장 한다)**
- **Calculator.add() ⇒ 매소드 즉, 매소드를 호출 한 것**
- **(10,20) ⇒ 매개값**

### 객체 간의 관계

- **집합 관계 : 자동차와 부품은 집합 관계**
- **사용 관계 : 자동차와 사람은 사용 관계**
- **상속 관계 : 자동차와 기계는 상속 관계**

### 📌객체 지향 프로그래밍

<aside>
📖 집합, 사용관계에 있는 객체를 하나씩 조립하여 프로그램을 개발

</aside>

**만들고자 하는 객체를 모델링하고, 집합관계의 객체와 사용관계 객체를 하나씩 설계한 후**

**조립하는 방식으로 프로그램을 개발하는 기법**

### 📌클래스

- **자바의 설계도**
- **인스턴스(Instance) : 클래스로부터 만들어진 객체**
- **객체 지향 프로그래밍 단계**

**: 클래스 설계 → 설계된 클래스로 사용할 객체 생성 → 객체 이용**

![Untitled 1](https://user-images.githubusercontent.com/80089860/162865202-04d9ff0a-bfd1-495a-9f99-30a9187f7c99.png)

😬

 **ㅇ 자바에서는 설계도가 클래스(class)** 

 **ㅇ 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(Instance)**

### **public 접근 제한자**

<aside>
📖 public 접근 제한자는 “파일 이름”과 동일한 “클래스 선언(클래스명)”에만 붙일 수 있습니다

</aside>

**자세한 내용은 뒤에서 다룰 예정*

### 클래스 선언

**클래스 이름은 다른 클래스와 식별할 목적으로 작성 규칙이 있다**

- **하나 이상의 문자로 이루어져야 한다 Car, SpotsCar**
- **첫 글자에는 숫자가 올 수 없다**
- **‘$’, ‘_’ 이외의 특수 문자는 사용할 수 없다**
- **자바 키워드는 사용할 수 없다 int(x), for(x)**

### 객체 생성과 클래스

![Untitled 2](https://user-images.githubusercontent.com/80089860/162865233-1e3f5ffe-3da2-429b-ada3-519c78352297.png)

*여기서 int[] arr = new int[3]; 에서 ‘3’은 배열의 길이를 나타낸다

<aside>
📖 new 클래스(); // 클래스로부터 “객체”를 생성시키는 연산자

</aside>

**“배열[]”과 “String 타입 참조변수”는 모두 “객체”에 해당하므로, new 연산자를 통해 생성할 수 있다** 

📌

😬**쉽게 말해, new 연산자는 “객체”를 생성하는 연산자**

**new 연산자 뒤에는 “생성자”가 오는데, 생성자는 “클래스()” 의 형태를 가지고 있다**

**new 연산자로 생성된 객체는 힙(heap)영역에 생성된다**

힙(heap)영역에 객체를 생성시킨 후 객체의 ***번지를 리턴하도록 한다(참조***) 

<aside>
📖 클래스 변수;                                                                                                                                 변수 = new 클래스();

</aside>

<br>

<aside>
📖 클래스 변수 = new 클래스();

</aside>

위의 두 줄을, 아래 한 줄 처럼 사용 가능

![Untitled 3](https://user-images.githubusercontent.com/80089860/162865269-0da5eeea-76b8-4eec-9446-1b21f3742f56.png)

### 클래스의 두 용도

- **라이브러리(API) 클래스**
    - **객체 생성 및 메소드 제동 역할 Student.java**
- **실행 클래스**
    - **main() 메소드 제공 역할 StudentExample.java**
    

---

## 클래스멤버

![Untitled 4](https://user-images.githubusercontent.com/80089860/162865288-b810c6b4-9f14-4ecf-aa8d-754e381df304.png)

- **필드(Field)**

**: 객체의 데이터가 저장되는곳** 

- **생성자(Contructor)**

**: 객체 생성 시, 초기화 역할 담당**

- **메소드(Method)**

**: 객체의 동작에 해당하는 실행 블록**

---

## 필드(Field)

- 📌**쉽게 말해, 변수선언과 비슷하다,**
- 📌**변수(데이터를 저장할 공간)처럼 “객체의 데이터를 저장할 공간”**

**: 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳입니다. 선언형태는**

**변수와 비슷하지만, 필드를 변수라고 부르지는 않습니다.**

**변수는 생성자와 메소드 내에서만 사용되고, 생성자와 메소드가 실행되면 자동 소멸됩니다.**

**하지만, 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재합니다.**

- **변수와 필드의 차이점 :**
    - **변수는 생성자와 메소드가 실행되면 죽는다**
    - **필드는 생성자와 메소드 전체에서 사용되며, 객체가 죽지않는 이상 함께 존재**
    

### 필드의 초기화

![Untitled 5](https://user-images.githubusercontent.com/80089860/162865325-23f9a3fd-c1c6-4917-807b-6d9c5649abba.png)

- 해석 : *name의 값을 (this.name → 내 필드안에 ) 저장해라 !*
    - ***name 값을 내 필드안에 저장하라!***
- ***Korean(String name, String ssn) 처럼 매개변수(String name, String ssn)은 필드이름과 동일하게 짓는다. 
따라서, 필드이름과 name(필드) = name(매개변수); 가 같을 경우, 필드앞에 this를 붙인다***

## 생성자(Constructor)

***생성자의 형태*** 

**car() {**

**}**

***메소드의 형태***

***void sum(int a, int b) {***

***}***

<aside>
📌 생성자 혹은 메소드안에 생긴것은 필드가 아니라, 변수(로컬변수)이다.

</aside>

- 📌**필드 및 객체의 초기화(값 저장)을 담당**
- 📌**생성자 이름은 클래스 이름과 동일하고 반환 값(리턴)이 없으며 상속되지 않는다.**
- 📌**생성자는 반환값이 없지만,** 📌**반환 타입을 void형으로 선언하지 않습니다.**

**: 생성자는 new 연산자로 호출되는 특별한 중괄화 {} 블록입니다. 생성자의 역할은 객체 생성 시 초기화를 담당합니다. 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 합니다. 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없습니다.**

***-객체 초기화 : 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것***

⇒즉, 값저장

**예시**

**Car myCar = new Car();**

**Car(); 라는 클래스와 똑같은 이름의 이녀석은 생성자입니다. = 생성자를 호출하는 코드**

![Untitled 6](https://user-images.githubusercontent.com/80089860/162865364-f7587f54-edbb-42f0-8c1c-21854fe768f2.png)

![Untitled 7](https://user-images.githubusercontent.com/80089860/162865371-1a8d3ae9-19da-4302-9d50-1370a33a332d.png)

- 📌
***두개의 다른 클래스인데, 하나의 클래스에서 같은 패키지안에 있는 다른 클래스의 객체를 생성해서 생성자를 호출한다(?)***
- ***객체를 생성(new)하는 쪽은 main 메소드 안에 있다 → 출력하는 쪽도 main 메소드가 있는 곳***

## 생성자의 오버로딩

**똑같은 생성자를 두 개이상 만드는 것을 의미한다. 이 때, 매개변수는 다르다**

**⇒ 오버로딩 하는 이유 : 하나의 생성자에 대한 많은 데이터(매개변수,매개값)이 있을 경우**

**즉, 매개변수를 달리하는 똑같은 생성자를 여러개 선언하는 것을 말한다** 

![Untitled 8](https://user-images.githubusercontent.com/80089860/162865395-cbd9b6a8-b00c-4bf6-a53b-28f833cdb4c0.png)

![Untitled 9](https://user-images.githubusercontent.com/80089860/162865402-84e0b1d4-f82a-41d1-b5f1-00b84581ccb7.png)

## 메소드(Method)

***생성자의 형태*** 

**car() {**

**}**

***메소드의 형태 : 메소드는 수행한(동작한)것의 결과값을 돌려줘야 하기때문에 return이 대부분 있다***

***void sum(int a, int b) {***

***}***

<aside>
📌 생성자 혹은 메소드안에 생긴것은 필드가 아니라, 변수(로컬변수)이다.

</aside>

- **선언부 : 메소드 선언부는 ( 리턴 타입(void), 매소드 이름, { 매개 변수 }; )로 구성된다**
- **📌void : 메소드(동작,기능)에서 📌리턴값이 오지 않는 경우에는 리턴타입을 void로 정의해야 한다**
- **매개 변수 : 메소드 호출 시, 매개값은 매개 변수에 차례되어 대입되어, 실행 블록에서 이용된다**
- **📌return(리턴문) :  “리턴 타입”이 있다면, 리턴값을 지정하기 위해**
    
    **“return”문이 반드시 있어야 한다** 
    
    **만약, 리턴 타입이 void라면 “return”문은 필요없지만,**
    
    **메소드(동작)을 종료시키기 위해 필요할 수 도 있다**
    
- **호출 : 메소드를 실행하려면 ‘ 메소드 이름(매개값...)’ 형태로 호출**
- **📌오버로딩 : 같은 메소드의 이름을 여러 개 선언하는 것을 ‘메소드 오버로딩’이라고 한다**

**오버로딩의 조건은 ‘매개변수 타입’, ‘개수’, ‘순서’ 중 하나가 달라야 한다**

**: 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말합니다. 중괄화 블록은 이름을 가지고 있는데, 이것이 메소드 이름입니다. 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됩니다. 이때 메소드는 필드를 읽고 수정하는 역할도 있지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 합니다. 메소드는 객체 간의 데이터를 전달하는 수단입니다. 외부(호출한 곳)으로 부터 매개값을 받아 실행에 이용하고 실행한 후 결과 값을 외부(호출한 곳)으로 리턴(돌려) 줄 수도 있습니다.**

![Untitled 10](https://user-images.githubusercontent.com/80089860/162865417-eb9e759e-18ea-43aa-bd37-76d98485b339.png)

- **리턴 타입 : 메소드가 리턴하는 결과의 타입을 표시합니다**
- **메소드 이름 : 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어줍니다**
- **매개 변수 선언 : 메소드를 실행할 때 필요한 데이터를 받기 위한 변수를 선언합니다**
- **메소드 실행 블록 : 실행할 코드를 작성합니다**

### 메소드 이름

- **메소드 이름은 관례적으로 소문자로 작성**

### 메소드 선언

📌**선언부(리턴 타입, 메소드 이름, 매개 변수 선언) 과**

**실행블록(동작,기능)으로 구성된다**

- **리턴값 : 메소드 실행한 후의 “결과값”**
- **리턴타입 : 리턴 받는(결과값)의 타입**

📌**⇒ 리턴값이 없을 경우 리턴타입을 “void”로 해야 한다**

📌**즉, 메소드에서 결과값이 나오는 경우는, 결과값에 알맞는 리턴타입을 가지게 된다**

**하지만, 메소드에서 결과값이 없는 경우는 void로 리턴타입을 정의해야 한다**

![Untitled 11](https://user-images.githubusercontent.com/80089860/162865432-ddec7072-5a20-43c8-ae96-dbd3ad57aeae.png)

### 매개 변수의 개수를 모를 경우

- 매개 변수를 **“배열 타입”**으로 선언
- 배열을 생성하지 않고 **값의 목록만 넘겨주는 방식**

### 리턴(return)문

- **리턴값이 있는 메소드**

<aside>
📖 retrun 리턴값;

</aside>

***자동타입 변환 ( 작은 타입에서 ⇒ 큰 타입)** 

**예시. byte, short, int값은 int로 자동변환된다**

```
int plus(int x, int y) {
	int result = x + y;
	return result;
}
```

- **리턴값이 없는 메소드**

**리턴값이 없는 메소드는 리턴 타입으로 void를 사용합니다. 그런데 void로 선언된 메소드에서도**

**return문을 사용할 수 있습니다. 이것은 메소드를 강제 종료시키는 역할을 한다**

**즉, return 만 덩그러니 있다면 메소드를 강제 종료시킨다는 뜻이다**

<aside>
📖 같은 패키지 다른 클래스의 메소드를 호출 할때, 객체를 생성하고 set으로 부르는 듯 하다

</aside>

- **set은 가져와서 변경한다 라는 의미인듯 싶다**

****메소드 호출 및 오버로딩은 생성자와 비슷(?)***

### 메소드 실습

![Untitled 12](https://user-images.githubusercontent.com/80089860/162865464-d839c7ea-265c-4ceb-8184-b97e58b23d9e.png)

![Untitled 13](https://user-images.githubusercontent.com/80089860/162865470-688edc69-ab4f-4c21-8d25-e4ea4d55cf0c.png)

---

## *인스턴스 멤버와 정적 멤버*

### 핵심 포인트

- **인스턴스 멤버 : 객체를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다**
- **this :  객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있습니다. 예를 들어, this.model은 자신이 가지고 잇는 model 필드라는 뜻입니다. this 주로 생성자와 메소드의 매개 변수 이름이 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다**

📌

- **정적 멤버 : 클래스에 고정된(”정적”) 멤버로서, 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다**
- **static : “정적 멤버를 선언할 때 상용하는 키워드”**
- **싱글톤 : 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있습니다.**
    
    **단, 하나만 생성된다고 해서 이 객체를 싱글톤(singleton)이라고 한다**
    

- **final 필드 : 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없는 필드를 말한다 final 필드는 final 키워드로 선언한다**
- **상수 : 수학에서 사용되는 원주율 파이나 지구의 무게 및 둘레같은 불변의 값을 저장하는 필드를 자바에서는 상수라고 합니다. 상수는 final static 키워드로 선언한다**

---

### 인스턴스 멤버

**: 객체마다 가지고 있는 멤버 = 객체를 생성한 후 사용할 수 있는 필드와 메소드**

- **(인스턴스) 필드 : 힙 영역의 객체마다 가지고 있는 멤버, 객체마다 다른 데이터들 저장**
- **(인스턴스) 메소드 :  객체가 있어야 호출 가능한 메소드**

```
**pulbic class Car {
//필드  == (인스턴스 필드)
int gas;

//메소드 == (인스턴스 메소드)
void setSpeed(int speed) {

}

위의 인스턴스필드(필드)와 인스턴스메소드(메소드)를 사용하기 위해서는,
객체를 먼저 만들어야 한다

ex)**
**Car myCar = new Car(); **myCar는 Stack영역에 생성(참조용), Car(Heap)영역에 생성
myCar.gas = 10; 
myCar.setSpeed(60);**
📌
**// 여기서 gas 및 setSpeed는 myCar라는 객체를 생성해야지만 사용이 가능하기 때문에,
인스턴스 필드, 인스턴스 메소드 라고한다

Car yourCar = new Car();
yourCar.gas = 20;
yourCar.setSpeed(80);**

```

![Untitled 14](https://user-images.githubusercontent.com/80089860/162865492-82e33c25-5194-4400-9991-e515ffe0764b.png)

### this

- **객체 내에서 인스턴스 멤버에 접근하기 위해 사용**
- **생성자와 메소드의 매개 벼눗 이름이 필드와 동일할 경우, 필드 임을 지정하기 위해 주로 사용**

![Untitled 15](https://user-images.githubusercontent.com/80089860/162865500-d88afb6e-1cb9-4de7-82b4-93d44c63247b.png)

```
public class Car {
//필드
String model;
int speed;

//생성자
Car(String model) {
	this.model = model;
}
//메소드
void setSpeed(int speed) {
	this.speed = speed;
}

void run() {
	for(int i=10; i=50; i+=10) {
	this.setSpeed(i);
	System.out.println(this.model + "가 달립니다.(시속:" + this.speed + "km/h)");
		}
	}
}
```

```
public class CarExample {
	
	public static void main(String[] args) {
		Car myCar = new Car("볼보");
		Car yourCar = new Car("붕붕이");
		
		myCar.run();
		yourCar.run();
	}
}
```

### 정적 멤버

**: 객체와 상관없는 멤버, 클래스 코드(메소드) 영역에 위치**

**정적(static)은 ‘고정된’이라는 의미입니다. 정적멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고, 사용할 수 있는 필드와 메소드를 말합니다. 이들을 각각 정적필드, 정적메소드라고 부릅니다**

- *정적은 프로그램 실행 전에, 만들어져있는 고정된 값이고 
동적은 실행하면서 만들어지는 변수로 알고 있다.*
- **정적 필드 및 상수 : 객체 없이 클래스만으로도 사용가능한 필드**
- **정적 메소드 :  객체 없이 클래스만으로도 호출 가능한 메소드**

![Untitled 16](https://user-images.githubusercontent.com/80089860/162865517-b914b7b3-b3c5-40d9-985b-a7fd6a85c29b.png)

![Untitled 17](https://user-images.githubusercontent.com/80089860/162865521-a92cf621-869b-4b87-8538-94c06d960b08.png)

### 인스턴스와 정적 멤버의 선택 기준

- **객체마다 다를 수 있는 필드값 → 인스턴스 필드로 선언 → static 안붙이면 된다**
- **객체마다 다를 필요가 없는 필드값 → 정적 필드로 선언 → this. 를 쓸 수 없다**
    - ***몸무게 → 인스턴스 필드 → why? 내 몸무게는 82kg, 친구 몸무게는 80kg 다를 수 있다***
    - ***pi → 정적 필드 → why? pi(파이) = 3.14이다. 곧 죽어도, 안바뀌는 고정된 값***

```
public Class Calculator {
	String color; //계산기별로 색상이 다를 수 있으므로, 인스턴스 필드로 선언
	static double pi = 3.14159; //계산기에서 파이값은 모두 동일하므로, 정적필드로 선언
}
```

### 정적메소드 선언 시, 주의할 점

- **정적 메소드 선언 시, 메소드 내부에 있는 인스턴스 필드 및 메소드 사용이 불가능!**
- **정적 메소드 선언 시, 그 객체 자신 참조인 this 키워드 사용불가**

```
//정적 메소드 선언시, 주의할점
public class ClassName {

	//인스턴스 필드와 메소드
	int field;
	void method() {	
	}
	//정적 필드와 메소드
	static int field2;
	static void method2() {	
	}
	//정적 메소드
	static void method3() {
	
	/*
	this.field1 = 10; //컴파일 에러 
	this.method(); //컴파일 에러
	주의할점1 : 정적 메소드 내에서는 this를 사용할 수 없다
	*/	
	// field1 = 10;
	// method1();
	// 주의할점2:  정적 메소드 내에서는 인스턴스 필드 및 메소드를 사용할 수 없다
		
	field2 = 10;
	method2();	
	}
}
```

![Untitled 18](https://user-images.githubusercontent.com/80089860/162865533-08f5be5d-823c-4ddb-ac4f-cbe0c52d53a9.png)

- *static이 있는 main메소드에서 필드와 메소드에 있는 speed와 run메소드를 실행하려면,
필드와 메소드에서 static을 붙여 정적필드, 정적메소드로 바꿔야만 static main 메소드에서 사용할 수 있다.*

**혹은 아래처럼 만들어 사용할 수 있다.**

![Untitled 19](https://user-images.githubusercontent.com/80089860/162865552-d6675063-7d37-4787-b109-edbd3d625002.png)

📌 📌

### 싱글톤

**앱이 시작될때 최초한번만 메모리를 할당하고** 

**그 메모리에 인스턴스(객체)를 만들어 사용하는 디자인 패턴.**

**사용이유 : 메모리 낭비를 방지하기 위해, 전역 인스턴스이기 때문에, 데이터 공유가 쉽다.**

**문제점 : 많은 데이터를 공유시킬경우, 수정이 어려워지고 테스트하기 어려워진다.**

**가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있습니다.** 

**단 하나만 생성된다고 해서 이 객체를 싱글톤이라고 합니다.**

<aside>
📖 즉, 전체 프로그램에서 단 하나의 객체만 만들도록 보장하는 코딩기법

</aside>

### 싱글톤 작성방법

- **private 접근 제한자 사용(클래스 외부에서 new 연산자를 통해 생성자 호출금지)**
- **자신의 타입인 정적 필드 선언 후, 자신의 객체 생성해 초기화**
- **외부에서 호출 할 수 있는 getInstance() 선언**

***(getInstance 메소드를 통해 한번만 생성된 객체를 가져온다)***

- **정적 필드에서 참조하는 자신의 객체 리턴**

![Untitled 20](https://user-images.githubusercontent.com/80089860/162865575-bfe32095-20c7-44c1-b880-f5570e4d0b7d.png)

### Final 필드

- **초기값이 저장되면 최종값이 되어 프로그램 실행 도중 수정 불가**
- **final 필드의 초기값 주는 방법**

**단순 값일 경우 필드 선언 시, 초기화(주로 정적필드(상수)일 경우)**

**객체 생성 시, 외부 데이터로 초기화 필요한 경우 생성자에서 초기화(주로 인스턴스 필드 경우)**

- **인스턴스 final  필드**

**객체에 한번 초기화된 데이터를 변경 불가로 만들 경우 : ex) 주민번호**

<aside>
📖 final 타입 필드 [=초기값];

</aside>

- **정적 final 필드(관례적으로 모두 대문자로 작성)**

**불편의 값인 상수를 만들경우 ex) PI**

**static final 타입 상수 = 초기값;**

---

## 패키지와 접근제한자

- **패키지 선언**
- **접근 제한자**
- **클래스의 접근제한**
- **생성자의 접근제한**
- **필드와 메소드의 접근제한**
- **Getter와 Setter 메소드**
- **키워드로 끝내는 핵심 포인트**

### 접근 제한자

- ***public 접근 제한자***
    - **외부 클래스가 자유롭게 사용할 수 있도록 함**
- ***protected  접근 제한자***
    - **같은 패키지 또는 자식 클래스에서 사용할 수 있도록 함**
- ***private 접근 제한자***
    - **외부에서 사용할 수 없도록 함**
- ***default 접근 제한***
    - **같은 패키지에 소속된 클래스에서만 사용할 수 있도록 함**
